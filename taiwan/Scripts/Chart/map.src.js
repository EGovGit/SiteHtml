"use strict"; !function (t) { "object" == typeof module && module.exports ? module.exports = t : t(Highcharts) }(function (t) { var i, e, o, a, n; e = (i = t).Axis, o = i.each, a = i.pick, (n = i.wrap)(e.prototype, "getSeriesExtremes", function (t) { var i, e, n, s = this.isXAxis, r = []; s && o(this.series, function (t, i) { t.useMapGeometry && (r[i] = t.xData, t.xData = []) }), t.call(this), s && (i = a(this.dataMin, Number.MAX_VALUE), e = a(this.dataMax, -Number.MAX_VALUE), o(this.series, function (t, o) { t.useMapGeometry && (i = Math.min(i, a(t.minX, i)), e = Math.max(e, a(t.maxX, e)), t.xData = r[o], n = !0) }), n && (this.dataMin = i, this.dataMax = e)) }), n(e.prototype, "setAxisTranslation", function (t) { var i, e, a, n, s, r = this.chart, l = r.plotWidth / r.plotHeight, h = r.xAxis[0]; t.call(this), "yAxis" === this.coll && void 0 !== h.transA && o(this.series, function (t) { t.preserveAspectRatio && (s = !0) }), s && (this.transA = h.transA = Math.min(this.transA, h.transA), i = ((e = l / ((h.max - h.min) / (this.max - this.min)) < 1 ? this : h).max - e.min) * e.transA, e.pixelPadding = e.len - i, e.minPixelPadding = e.pixelPadding / 2, (a = e.fixTo) && (n = a[1] - e.toValue(a[0], !0), n *= e.transA, (Math.abs(n) > e.minPixelPadding || e.min === e.dataMin && e.max === e.dataMax) && (n = 0), e.minPixelPadding -= n)) }), n(e.prototype, "render", function (t) { t.call(this), this.fixTo = null }), function (t) { var i, e = t.Axis, o = t.Chart, a = t.color, n = t.each, s = t.extend, r = t.isNumber, l = t.Legend, h = t.LegendSymbolMixin, p = t.noop, c = t.merge, d = t.pick, u = t.wrap; t.ColorAxis || (i = t.ColorAxis = function () { this.init.apply(this, arguments) }, s(i.prototype, e.prototype), s(i.prototype, { defaultColorAxisOptions: { lineWidth: 0, minPadding: 0, maxPadding: 0, gridLineWidth: 1, tickPixelInterval: 72, startOnTick: !0, endOnTick: !0, offset: 0, marker: { animation: { duration: 50 }, width: .01, color: "#999999" }, labels: { overflow: "justify", rotation: 0 }, minColor: "#e6ebf5", maxColor: "#003399", tickLength: 5, showInLegend: !0 }, keepProps: ["legendGroup", "legendItemHeight", "legendItemWidth", "legendItem", "legendSymbol"].concat(e.prototype.keepProps), init: function (t, i) { var o, a = "vertical" !== t.options.legend.layout; this.coll = "colorAxis", o = c(this.defaultColorAxisOptions, { side: a ? 2 : 1, reversed: !a }, i, { opposite: !a, showEmpty: !1, title: null, visible: t.options.legend.enabled }), e.prototype.init.call(this, t, o), i.dataClasses && this.initDataClasses(i), this.initStops(), this.horiz = a, this.zoomEnabled = !1, this.defaultLegendLength = 200 }, initDataClasses: function (t) { var i, e = this.chart, o = 0, s = e.options.chart.colorCount, r = this.options, l = t.dataClasses.length; this.dataClasses = i = [], this.legendItems = [], n(t.dataClasses, function (t, n) { var h; t = c(t), i.push(t), t.color || ("category" === r.dataClassColor ? (h = e.options.colors, s = h.length, t.color = h[o], t.colorIndex = o, ++o === s && (o = 0)) : t.color = a(r.minColor).tweenTo(a(r.maxColor), l < 2 ? .5 : n / (l - 1))) }) }, setTickPositions: function () { if (!this.dataClasses) return e.prototype.setTickPositions.call(this) }, initStops: function () { this.stops = this.options.stops || [[0, this.options.minColor], [1, this.options.maxColor]], n(this.stops, function (t) { t.color = a(t[1]) }) }, setOptions: function (t) { e.prototype.setOptions.call(this, t), this.options.crosshair = this.options.marker }, setAxisSize: function () { var t, i, e, o, a = this.legendSymbol, n = this.chart, s = n.options.legend || {}; a ? (this.left = t = a.attr("x"), this.top = i = a.attr("y"), this.width = e = a.attr("width"), this.height = o = a.attr("height"), this.right = n.chartWidth - t - e, this.bottom = n.chartHeight - i - o, this.len = this.horiz ? e : o, this.pos = this.horiz ? t : i) : this.len = (this.horiz ? s.symbolWidth : s.symbolHeight) || this.defaultLegendLength }, normalizedValue: function (t) { return this.isLog && (t = this.val2lin(t)), 1 - (this.max - t) / (this.max - this.min || 1) }, toColor: function (t, i) { var e, o, a, n, s, r, l = this.stops, h = this.dataClasses; if (h) { for (r = h.length; r--;)if (o = (s = h[r]).from, a = s.to, (void 0 === o || t >= o) && (void 0 === a || t <= a)) { n = s.color, i && (i.dataClass = r, i.colorIndex = s.colorIndex); break } } else { for (e = this.normalizedValue(t), r = l.length; r-- && !(e > l[r][0]);); o = l[r] || l[r + 1], e = 1 - ((a = l[r + 1] || o)[0] - e) / (a[0] - o[0] || 1), n = o.color.tweenTo(a.color, e) } return n }, getOffset: function () { var t = this.legendGroup, i = this.chart.axisOffset[this.side]; t && (this.axisParent = t, e.prototype.getOffset.call(this), this.added || (this.added = !0, this.labelLeft = 0, this.labelRight = this.width), this.chart.axisOffset[this.side] = i) }, setLegendColor: function () { var t, i = this.horiz, e = this.reversed, o = e ? 1 : 0, a = e ? 0 : 1; t = i ? [o, 0, a, 0] : [0, a, 0, o], this.legendColor = { linearGradient: { x1: t[0], y1: t[1], x2: t[2], y2: t[3] }, stops: this.stops } }, drawLegendSymbol: function (t, i) { var e = t.padding, o = t.options, a = this.horiz, n = d(o.symbolWidth, a ? this.defaultLegendLength : 12), s = d(o.symbolHeight, a ? 12 : this.defaultLegendLength), r = d(o.labelPadding, a ? 16 : 30), l = d(o.itemDistance, 10); this.setLegendColor(), i.legendSymbol = this.chart.renderer.rect(0, t.baseline - 11, n, s).attr({ zIndex: 1 }).add(i.legendGroup), this.legendItemWidth = n + e + (a ? l : r), this.legendItemHeight = s + e + (a ? r : 0) }, setState: function (t) { n(this.series, function (i) { i.setState(t) }) }, visible: !0, setVisible: p, getSeriesExtremes: function () { var t = this.series, i = t.length; for (this.dataMin = 1 / 0, this.dataMax = -1 / 0; i--;)void 0 !== t[i].valueMin && (this.dataMin = Math.min(this.dataMin, t[i].valueMin), this.dataMax = Math.max(this.dataMax, t[i].valueMax)) }, drawCrosshair: function (t, i) { var o, a = i && i.plotX, n = i && i.plotY, s = this.pos, r = this.len; i && ((o = this.toPixels(i[i.series.colorKey])) < s ? o = s - 2 : o > s + r && (o = s + r + 2), i.plotX = o, i.plotY = this.len - o, e.prototype.drawCrosshair.call(this, t, i), i.plotX = a, i.plotY = n, this.cross && !this.cross.addedToColorAxis && this.legendGroup && (this.cross.addClass("highcharts-coloraxis-marker").add(this.legendGroup), this.cross.addedToColorAxis = !0, this.cross.attr({ fill: this.crosshair.color }))) }, getPlotLinePath: function (t, i, o, a, n) { return r(n) ? this.horiz ? ["M", n - 4, this.top - 6, "L", n + 4, this.top - 6, n, this.top, "Z"] : ["M", this.left, n, "L", this.left - 6, n + 6, this.left - 6, n - 6, "Z"] : e.prototype.getPlotLinePath.call(this, t, i, o, a) }, update: function (t, i) { var o = this.chart, a = o.legend; n(this.series, function (t) { t.isDirtyData = !0 }), t.dataClasses && a.allItems && (n(a.allItems, function (t) { t.isDataClass && t.legendGroup && t.legendGroup.destroy() }), o.isDirtyLegend = !0), o.options[this.coll] = c(this.userOptions, t), e.prototype.update.call(this, t, i), this.legendItem && (this.setLegendColor(), a.colorizeItem(this, !0)) }, remove: function () { this.legendItem && this.chart.legend.destroyItem(this), e.prototype.remove.call(this) }, getDataClassLegendSymbols: function () { var i, e = this, o = this.chart, a = this.legendItems, r = o.options.legend, l = r.valueDecimals, c = r.valueSuffix || ""; return a.length || n(this.dataClasses, function (r, d) { var u = !0, m = r.from, f = r.to; i = "", void 0 === m ? i = "< " : void 0 === f && (i = "> "), void 0 !== m && (i += t.numberFormat(m, l) + c), void 0 !== m && void 0 !== f && (i += " - "), void 0 !== f && (i += t.numberFormat(f, l) + c), a.push(s({ chart: o, name: i, options: {}, drawLegendSymbol: h.drawRectangle, visible: !0, setState: p, isDataClass: !0, setVisible: function () { u = this.visible = !u, n(e.series, function (t) { n(t.points, function (t) { t.dataClass === d && t.setVisible(u) }) }), o.legend.colorizeItem(this, u) } }, r)) }), a }, name: "" }), n(["fill", "stroke"], function (i) { t.Fx.prototype[i + "Setter"] = function () { this.elem.attr(i, a(this.start).tweenTo(a(this.end), this.pos), null, !0) } }), u(o.prototype, "getAxes", function (t) { var e = this.options.colorAxis; t.call(this), this.colorAxis = [], e && new i(this, e) }), u(l.prototype, "getAllItems", function (t) { var i = [], e = this.chart.colorAxis[0]; return e && e.options && (e.options.showInLegend && (e.options.dataClasses ? i = i.concat(e.getDataClassLegendSymbols()) : i.push(e)), n(e.series, function (t) { t.options.showInLegend = !1 })), i.concat(t.call(this)) }), u(l.prototype, "colorizeItem", function (t, i, e) { t.call(this, i, e), e && i.legendColor && i.legendSymbol.attr({ fill: i.legendColor }) }), u(l.prototype, "update", function (t) { t.apply(this, [].slice.call(arguments, 1)), this.chart.colorAxis[0] && this.chart.colorAxis[0].update({}, arguments[2]) })) }(t), function (t) { var i = t.defined, e = t.each, o = t.noop, a = t.seriesTypes; t.colorPointMixin = { isValid: function () { return null !== this.value && this.value !== 1 / 0 && this.value !== -1 / 0 }, setVisible: function (t) { var i = this, o = t ? "show" : "hide"; e(["graphic", "dataLabel"], function (t) { i[t] && i[t][o]() }) }, setState: function (i) { t.Point.prototype.setState.call(this, i), this.graphic && this.graphic.attr({ zIndex: "hover" === i ? 1 : 0 }) } }, t.colorSeriesMixin = { pointArrayMap: ["value"], axisTypes: ["xAxis", "yAxis", "colorAxis"], optionalAxis: "colorAxis", trackerGroups: ["group", "markerGroup", "dataLabelsGroup"], getSymbol: o, parallelArrays: ["x", "y", "value"], colorKey: "value", pointAttribs: a.column.prototype.pointAttribs, translateColors: function () { var t = this, i = this.options.nullColor, o = this.colorAxis, a = this.colorKey; e(this.data, function (e) { var n, s = e[a]; (n = e.options.color || (e.isNull ? i : o && void 0 !== s ? o.toColor(s, e) : e.color || t.color)) && (e.color = n) }) }, colorAttribs: function (t) { var e = {}; return i(t.color) && (e[this.colorProp || "fill"] = t.color), e } } }(t), function (t) { var i = t.addEvent, e = t.Chart, o = t.doc, a = t.each, n = t.extend, s = t.merge, r = t.pick, l = t.wrap; function h(t) { t && (t.preventDefault && t.preventDefault(), t.stopPropagation && t.stopPropagation(), t.cancelBubble = !0) } function p(t) { this.init(t) } p.prototype.init = function (t) { this.chart = t, t.mapNavButtons = [] }, p.prototype.update = function (e) { var o, a, l, p, c, d = this.chart, u = d.options.mapNavigation, m = function (t) { this.handler.call(d, t), h(t) }, f = d.mapNavButtons; for (e && (u = d.options.mapNavigation = s(d.options.mapNavigation, e)); f.length;)f.pop().destroy(); r(u.enableButtons, u.enabled) && !d.renderer.forExport && t.objectEach(u.buttons, function (t, e) { o = s(u.buttonOptions, t), (a = o.theme).style = s(o.theme.style, o.style), l = a.states, p = l && l.hover, c = l && l.select, (t = d.renderer.button(o.text, 0, 0, m, a, p, c, 0, "zoomIn" === e ? "topbutton" : "bottombutton").addClass("highcharts-map-navigation").attr({ width: o.width, height: o.height, title: d.options.lang[e], padding: o.padding, zIndex: 5 }).add()).handler = o.onclick, t.align(n(o, { width: t.width, height: 2 * t.height }), null, o.alignTo), i(t.element, "dblclick", h), f.push(t) }), this.updateEvents(u) }, p.prototype.updateEvents = function (t) { var e = this.chart; r(t.enableDoubleClickZoom, t.enabled) || t.enableDoubleClickZoomTo ? this.unbindDblClick = this.unbindDblClick || i(e.container, "dblclick", function (t) { e.pointer.onContainerDblClick(t) }) : this.unbindDblClick && (this.unbindDblClick = this.unbindDblClick()), r(t.enableMouseWheelZoom, t.enabled) ? this.unbindMouseWheel = this.unbindMouseWheel || i(e.container, void 0 === o.onmousewheel ? "DOMMouseScroll" : "mousewheel", function (t) { return e.pointer.onContainerMouseWheel(t), h(t), !1 }) : this.unbindMouseWheel && (this.unbindMouseWheel = this.unbindMouseWheel()) }, n(e.prototype, { fitToBox: function (t, i) { return a([["x", "width"], ["y", "height"]], function (e) { var o = e[0], a = e[1]; t[o] + t[a] > i[o] + i[a] && (t[a] > i[a] ? (t[a] = i[a], t[o] = i[o]) : t[o] = i[o] + i[a] - t[a]), t[a] > i[a] && (t[a] = i[a]), t[o] < i[o] && (t[o] = i[o]) }), t }, mapZoom: function (t, i, e, o, a) { var n = this.xAxis[0], s = n.max - n.min, l = r(i, n.min + s / 2), h = s * t, p = this.yAxis[0], c = p.max - p.min, d = r(e, p.min + c / 2), u = c * t, m = l - h * (o ? (o - n.pos) / n.len : .5), f = d - u * (a ? (a - p.pos) / p.len : .5), g = this.fitToBox({ x: m, y: f, width: h, height: u }, { x: n.dataMin, y: p.dataMin, width: n.dataMax - n.dataMin, height: p.dataMax - p.dataMin }), x = g.x <= n.dataMin && g.width >= n.dataMax - n.dataMin && g.y <= p.dataMin && g.height >= p.dataMax - p.dataMin; o && (n.fixTo = [o - n.pos, i]), a && (p.fixTo = [a - p.pos, e]), void 0 === t || x ? (n.setExtremes(void 0, void 0, !1), p.setExtremes(void 0, void 0, !1)) : (n.setExtremes(g.x, g.x + g.width, !1), p.setExtremes(g.y, g.y + g.height, !1)), this.redraw() } }), l(e.prototype, "render", function (t) { this.mapNavigation = new p(this), this.mapNavigation.update(), t.call(this) }) }(t), function (t) { var i = t.extend, e = t.pick, o = t.Pointer, a = t.wrap; i(o.prototype, { onContainerDblClick: function (t) { var i = this.chart; t = this.normalize(t), i.options.mapNavigation.enableDoubleClickZoomTo ? i.pointer.inClass(t.target, "highcharts-tracker") && i.hoverPoint && i.hoverPoint.zoomTo() : i.isInsidePlot(t.chartX - i.plotLeft, t.chartY - i.plotTop) && i.mapZoom(.5, i.xAxis[0].toValue(t.chartX), i.yAxis[0].toValue(t.chartY), t.chartX, t.chartY) }, onContainerMouseWheel: function (t) { var i, e = this.chart; i = (t = this.normalize(t)).detail || -t.wheelDelta / 120, e.isInsidePlot(t.chartX - e.plotLeft, t.chartY - e.plotTop) && e.mapZoom(Math.pow(e.options.mapNavigation.mouseWheelSensitivity, i), e.xAxis[0].toValue(t.chartX), e.yAxis[0].toValue(t.chartY), t.chartX, t.chartY) } }), a(o.prototype, "zoomOption", function (t) { var i = this.chart.options.mapNavigation; e(i.enableTouchZoom, i.enabled) && (this.chart.options.chart.pinchType = "xy"), t.apply(this, [].slice.call(arguments, 1)) }), a(o.prototype, "pinchTranslate", function (t, i, e, o, a, n, s) { var r; t.call(this, i, e, o, a, n, s), "map" === this.chart.options.chart.type && this.hasZoom && (r = o.scaleX > o.scaleY, this.pinchTranslateDirection(!r, i, e, o, a, n, s, r ? o.scaleX : o.scaleY)) }) }(t), function (t) { var i = t.colorPointMixin, e = t.colorSeriesMixin, o = t.doc, a = t.each, n = t.extend, s = t.isNumber, r = t.LegendSymbolMixin, l = t.map, h = t.merge, p = t.noop, c = t.pick, d = t.isArray, u = t.Point, m = t.Series, f = t.seriesType, g = t.seriesTypes, x = t.splat, y = void 0 !== o.documentElement.style.vectorEffect; f("map", "scatter", { allAreas: !0, animation: !1, nullColor: "#f7f7f7", borderColor: "#cccccc", borderWidth: 1, marker: null, stickyTracking: !1, joinBy: "hc-key", dataLabels: { formatter: function () { return this.point.value }, inside: !0, verticalAlign: "middle", crop: !1, overflow: !1, padding: 0 }, turboThreshold: 0, tooltip: { followPointer: !0, pointFormat: "{point.name}: {point.value}<br/>" }, states: { normal: { animation: !0 }, hover: { halo: null, brightness: .2 }, select: { color: "#cccccc" } } }, h(e, { type: "map", getExtremesFromAll: !0, useMapGeometry: !0, forceDL: !0, searchPoint: p, directTouch: !0, preserveAspectRatio: !0, pointArrayMap: ["value"], getBox: function (i) { var e, o = Number.MAX_VALUE, n = -o, r = o, l = -o, h = o, p = o, d = this.xAxis, u = this.yAxis; a(i || [], function (i) { if (i.path) { "string" == typeof i.path && (i.path = t.splitPath(i.path)); var a = i.path || [], d = a.length, u = !1, m = -o, f = o, g = -o, x = o, y = i.properties; if (!i._foundBox) { for (; d--;)s(a[d]) && (u ? (m = Math.max(m, a[d]), f = Math.min(f, a[d])) : (g = Math.max(g, a[d]), x = Math.min(x, a[d])), u = !u); i._midX = f + (m - f) * c(i.middleX, y && y["hc-middle-x"], .5), i._midY = x + (g - x) * c(i.middleY, y && y["hc-middle-y"], .5), i._maxX = m, i._minX = f, i._maxY = g, i._minY = x, i.labelrank = c(i.labelrank, (m - f) * (g - x)), i._foundBox = !0 } n = Math.max(n, i._maxX), r = Math.min(r, i._minX), l = Math.max(l, i._maxY), h = Math.min(h, i._minY), p = Math.min(i._maxX - i._minX, i._maxY - i._minY, p), e = !0 } }), e && (this.minY = Math.min(h, c(this.minY, o)), this.maxY = Math.max(l, c(this.maxY, -o)), this.minX = Math.min(r, c(this.minX, o)), this.maxX = Math.max(n, c(this.maxX, -o)), d && void 0 === d.options.minRange && (d.minRange = Math.min(5 * p, (this.maxX - this.minX) / 5, d.minRange || o)), u && void 0 === u.options.minRange && (u.minRange = Math.min(5 * p, (this.maxY - this.minY) / 5, u.minRange || o))) }, getExtremes: function () { m.prototype.getExtremes.call(this, this.valueData), this.chart.hasRendered && this.isDirtyData && this.getBox(this.options.data), this.valueMin = this.dataMin, this.valueMax = this.dataMax, this.dataMin = this.minY, this.dataMax = this.maxY }, translatePath: function (t) { var i, e = !1, o = this.xAxis, a = this.yAxis, n = o.min, r = o.transA, l = o.minPixelPadding, h = a.min, p = a.transA, c = a.minPixelPadding, d = []; if (t) for (i = t.length; i--;)s(t[i]) ? (d[i] = e ? (t[i] - n) * r + l : (t[i] - h) * p + c, e = !e) : d[i] = t[i]; return d }, setData: function (i, e, o, n) { var r, p, c, u = this.options, f = this.chart.options.chart, g = f && f.map, y = u.mapData, v = u.joinBy, b = null === v, M = u.keys || this.pointArrayMap, A = [], L = {}, w = this.chart.mapTransforms; if (!y && g && (y = "string" == typeof g ? t.maps[g] : g), b && (v = "_i"), (v = this.joinBy = x(v))[1] || (v[1] = v[0]), i && a(i, function (t, e) { var o = 0; if (s(t)) i[e] = { value: t }; else if (d(t)) { i[e] = {}, !u.keys && t.length > M.length && "string" == typeof t[0] && (i[e]["hc-key"] = t[0], ++o); for (var a = 0; a < M.length; ++a, ++o)M[a] && (i[e][M[a]] = t[o]) } b && (i[e]._i = e) }), this.getBox(i), this.chart.mapTransforms = w = f && f.mapTransforms || y && y["hc-transform"] || w, w && t.objectEach(w, function (t) { t.rotation && (t.cosAngle = Math.cos(t.rotation), t.sinAngle = Math.sin(t.rotation)) }), y) { for ("FeatureCollection" === y.type && (this.mapTitle = y.title, y = t.geojson(y, this.type, this)), this.mapData = y, this.mapMap = {}, c = 0; c < y.length; c++)p = (r = y[c]).properties, r._i = c, v[0] && p && p[v[0]] && (r[v[0]] = p[v[0]]), L[r[v[0]]] = r; this.mapMap = L, i && v[1] && a(i, function (t) { L[t[v[1]]] && A.push(L[t[v[1]]]) }), u.allAreas ? (this.getBox(y), i = i || [], v[1] && a(i, function (t) { A.push(t[v[1]]) }), A = "|" + l(A, function (t) { return t && t[v[0]] }).join("|") + "|", a(y, function (t) { v[0] && -1 !== A.indexOf("|" + t[v[0]] + "|") || (i.push(h(t, { value: null })), n = !1) })) : this.getBox(A) } m.prototype.setData.call(this, i, e, o, n) }, drawGraph: p, drawDataLabels: p, doFullTranslate: function () { return this.isDirtyData || this.chart.isResizing || this.chart.renderer.isVML || !this.baseTrans }, translate: function () { var t = this, i = t.xAxis, e = t.yAxis, o = t.doFullTranslate(); t.generatePoints(), a(t.data, function (a) { a.plotX = i.toPixels(a._midX, !0), a.plotY = e.toPixels(a._midY, !0), o && (a.shapeType = "path", a.shapeArgs = { d: t.translatePath(a.path) }) }), t.translateColors() }, pointAttribs: function (t, i) { var e; return e = g.column.prototype.pointAttribs.call(this, t, i), y ? e["vector-effect"] = "non-scaling-stroke" : e["stroke-width"] = "inherit", e }, drawPoints: function () { var t, i, e, o, n, s, r, l, h, p = this, c = p.xAxis, d = p.yAxis, u = p.group, m = p.chart, f = m.renderer, x = this.baseTrans; p.transformGroup || (p.transformGroup = f.g().attr({ scaleX: 1, scaleY: 1 }).add(u), p.transformGroup.survive = !0), p.doFullTranslate() ? (m.hasRendered && a(p.points, function (t) { t.shapeArgs && (t.shapeArgs.fill = p.pointAttribs(t, t.state).fill) }), p.group = p.transformGroup, g.column.prototype.drawPoints.apply(p), p.group = u, a(p.points, function (t) { t.graphic && (t.name && t.graphic.addClass("highcharts-name-" + t.name.replace(/ /g, "-").toLowerCase()), t.properties && t.properties["hc-key"] && t.graphic.addClass("highcharts-key-" + t.properties["hc-key"].toLowerCase())) }), this.baseTrans = { originX: c.min - c.minPixelPadding / c.transA, originY: d.min - d.minPixelPadding / d.transA + (d.reversed ? 0 : d.len / d.transA), transAX: c.transA, transAY: d.transA }, this.transformGroup.animate({ translateX: 0, translateY: 0, scaleX: 1, scaleY: 1 })) : (t = c.transA / x.transAX, i = d.transA / x.transAY, e = c.toPixels(x.originX, !0), o = d.toPixels(x.originY, !0), t > .99 && t < 1.01 && i > .99 && i < 1.01 && (t = 1, i = 1, e = Math.round(e), o = Math.round(o)), n = this.transformGroup, m.renderer.globalAnimation ? (s = n.attr("translateX"), r = n.attr("translateY"), l = n.attr("scaleX"), h = n.attr("scaleY"), n.attr({ animator: 0 }).animate({ animator: 1 }, { step: function (a, p) { n.attr({ translateX: s + (e - s) * p.pos, translateY: r + (o - r) * p.pos, scaleX: l + (t - l) * p.pos, scaleY: h + (i - h) * p.pos }) } })) : n.attr({ translateX: e, translateY: o, scaleX: t, scaleY: i })), y || p.group.element.setAttribute("stroke-width", p.options[p.pointAttrToOptions && p.pointAttrToOptions["stroke-width"] || "borderWidth"] / (t || 1)), this.drawMapDataLabels() }, drawMapDataLabels: function () { m.prototype.drawDataLabels.call(this), this.dataLabelsGroup && this.dataLabelsGroup.clip(this.chart.clipRect) }, render: function () { var t = this, i = m.prototype.render; t.chart.renderer.isVML && t.data.length > 3e3 ? setTimeout(function () { i.call(t) }) : i.call(t) }, animate: function (t) { var i = this.chart, e = this.options.animation, o = this.group, a = this.xAxis, n = this.yAxis, s = a.pos, r = n.pos; i.renderer.isSVG && (!0 === e && (e = { duration: 1e3 }), t ? o.attr({ translateX: s + a.len / 2, translateY: r + n.len / 2, scaleX: .001, scaleY: .001 }) : (o.animate({ translateX: s, translateY: r, scaleX: 1, scaleY: 1 }, e), this.animate = null)) }, animateDrilldown: function (t) { var i, e = this.chart.plotBox, o = this.chart.drilldownLevels[this.chart.drilldownLevels.length - 1], n = o.bBox, s = this.chart.options.drilldown.animation; t || (i = Math.min(n.width / e.width, n.height / e.height), o.shapeArgs = { scaleX: i, scaleY: i, translateX: n.x, translateY: n.y }, a(this.points, function (t) { t.graphic && t.graphic.attr(o.shapeArgs).animate({ scaleX: 1, scaleY: 1, translateX: 0, translateY: 0 }, s) }), this.animate = null) }, drawLegendSymbol: r.drawRectangle, animateDrillupFrom: function (t) { g.column.prototype.animateDrillupFrom.call(this, t) }, animateDrillupTo: function (t) { g.column.prototype.animateDrillupTo.call(this, t) } }), n({ applyOptions: function (t, i) { var e, o = u.prototype.applyOptions.call(this, t, i), a = this.series, s = a.joinBy; return a.mapData && ((e = void 0 !== o[s[1]] && a.mapMap[o[s[1]]]) ? (a.xyFromShape && (o.x = e._midX, o.y = e._midY), n(o, e)) : o.value = o.value || null), o }, onMouseOver: function (t) { clearTimeout(this.colorInterval), null !== this.value || this.series.options.nullInteraction ? u.prototype.onMouseOver.call(this, t) : this.series.onMouseOut(t) }, zoomTo: function () { var t = this.series; t.xAxis.setExtremes(this._minX, this._maxX, !1), t.yAxis.setExtremes(this._minY, this._maxY, !1), t.chart.redraw() } }, i)) }(t), function (t) { var i = t.seriesType, e = t.seriesTypes; i("mapline", "map", { lineWidth: 1, fillColor: "none" }, { type: "mapline", colorProp: "stroke", pointAttrToOptions: { stroke: "color", "stroke-width": "lineWidth" }, pointAttribs: function (t, i) { var o = e.map.prototype.pointAttribs.call(this, t, i); return o.fill = this.options.fillColor, o }, drawLegendSymbol: e.line.prototype.drawLegendSymbol }) }(t), function (t) { var i = t.merge, e = t.Point; (0, t.seriesType)("mappoint", "scatter", { dataLabels: { enabled: !0, formatter: function () { return this.point.name }, crop: !1, defer: !1, overflow: !1, style: { color: "#000000" } } }, { type: "mappoint", forceDL: !0 }, { applyOptions: function (t, o) { var a = void 0 !== t.lat && void 0 !== t.lon ? i(t, this.series.chart.fromLatLonToPoint(t)) : t; return e.prototype.applyOptions.call(this, a, o) } }) }(t), function (t) { var i = t.arrayMax, e = t.arrayMin, o = t.Axis, a = t.color, n = t.each, s = t.isNumber, r = t.noop, l = t.pick, h = t.pInt, p = t.Point, c = t.Series, d = t.seriesType, u = t.seriesTypes; d("bubble", "scatter", { dataLabels: { formatter: function () { return this.point.z }, inside: !0, verticalAlign: "middle" }, marker: { lineColor: null, lineWidth: 1, fillOpacity: .5, radius: null, states: { hover: { radiusPlus: 0 } }, symbol: "circle" }, minSize: 8, maxSize: "20%", softThreshold: !1, states: { hover: { halo: { size: 5 } } }, tooltip: { pointFormat: "({point.x}, {point.y}), Size: {point.z}" }, turboThreshold: 0, zThreshold: 0, zoneAxis: "z" }, { pointArrayMap: ["y", "z"], parallelArrays: ["x", "y", "z"], trackerGroups: ["group", "dataLabelsGroup"], specialGroup: "group", bubblePadding: !0, zoneAxis: "z", directTouch: !0, pointAttribs: function (t, i) { var e = this.options.marker.fillOpacity, o = c.prototype.pointAttribs.call(this, t, i); return 1 !== e && (o.fill = a(o.fill).setOpacity(e).get("rgba")), o }, getRadii: function (t, i, e, o) { var a, n, s, r, l, h = this.zData, p = [], c = this.options, d = "width" !== c.sizeBy, u = c.zThreshold, m = i - t; for (n = 0, a = h.length; n < a; n++)r = h[n], c.sizeByAbsoluteValue && null !== r && (r = Math.abs(r - u), i = Math.max(i - u, Math.abs(t - u)), t = 0), null === r ? l = null : r < t ? l = e / 2 - 1 : (s = m > 0 ? (r - t) / m : .5, d && s >= 0 && (s = Math.sqrt(s)), l = Math.ceil(e + s * (o - e)) / 2), p.push(l); this.radii = p }, animate: function (t) { var i = this.options.animation; t || (n(this.points, function (t) { var e, o = t.graphic; o && o.width && (e = { x: o.x, y: o.y, width: o.width, height: o.height }, o.attr({ x: t.plotX, y: t.plotY, width: 1, height: 1 }), o.animate(e, i)) }), this.animate = null) }, translate: function () { var i, e, o, a = this.data, n = this.radii; for (u.scatter.prototype.translate.call(this), i = a.length; i--;)e = a[i], o = n ? n[i] : 0, s(o) && o >= this.minPxSize / 2 ? (e.marker = t.extend(e.marker, { radius: o, width: 2 * o, height: 2 * o }), e.dlBox = { x: e.plotX - o, y: e.plotY - o, width: 2 * o, height: 2 * o }) : e.shapeArgs = e.plotY = e.dlBox = void 0 }, alignDataLabel: u.column.prototype.alignDataLabel, buildKDTree: r, applyZones: r }, { haloPath: function (t) { return p.prototype.haloPath.call(this, 0 === t ? 0 : (this.marker && this.marker.radius || 0) + t) }, ttBelow: !1 }), o.prototype.beforePadding = function () { var t = this, o = this.len, a = this.chart, r = 0, p = o, c = this.isXAxis, d = c ? "xData" : "yData", u = this.min, m = {}, f = Math.min(a.plotWidth, a.plotHeight), g = Number.MAX_VALUE, x = -Number.MAX_VALUE, y = this.max - u, v = o / y, b = []; n(this.series, function (o) { var s, r = o.options; !o.bubblePadding || !o.visible && a.options.chart.ignoreHiddenSeries || (t.allowZoomOutside = !0, b.push(o), c && (n(["minSize", "maxSize"], function (t) { var i = r[t], e = /%$/.test(i); i = h(i), m[t] = e ? f * i / 100 : i }), o.minPxSize = m.minSize, o.maxPxSize = Math.max(m.maxSize, m.minSize), (s = o.zData).length && (g = l(r.zMin, Math.min(g, Math.max(e(s), !1 === r.displayNegative ? r.zThreshold : -Number.MAX_VALUE))), x = l(r.zMax, Math.max(x, i(s)))))) }), n(b, function (i) { var e, o = i[d], a = o.length; if (c && i.getRadii(g, x, i.minPxSize, i.maxPxSize), y > 0) for (; a--;)s(o[a]) && t.dataMin <= o[a] && o[a] <= t.dataMax && (e = i.radii[a], r = Math.min((o[a] - u) * v - e, r), p = Math.max((o[a] - u) * v + e, p)) }), b.length && y > 0 && !this.isLog && (v *= (o + r - (p -= o)) / o, n([["min", "userMin", r], ["max", "userMax", p]], function (i) { void 0 === l(t.options[i[0]], t[i[1]]) && (t[i[0]] += i[2] / v) })) } }(t), function (t) { var i = t.merge, e = t.Point, o = t.seriesType, a = t.seriesTypes; a.bubble && o("mapbubble", "bubble", { animationLimit: 500, tooltip: { pointFormat: "{point.name}: {point.z}" } }, { xyFromShape: !0, type: "mapbubble", pointArrayMap: ["z"], getMapData: a.map.prototype.getMapData, getBox: a.map.prototype.getBox, setData: a.map.prototype.setData }, { applyOptions: function (t, o) { return t && void 0 !== t.lat && void 0 !== t.lon ? e.prototype.applyOptions.call(this, i(t, this.series.chart.fromLatLonToPoint(t)), o) : a.map.prototype.pointClass.prototype.applyOptions.call(this, t, o) }, isValid: function () { return "number" == typeof this.z }, ttBelow: !1 }) }(t), function (t) { var i = t.colorPointMixin, e = t.colorSeriesMixin, o = t.each, a = t.LegendSymbolMixin, n = t.merge, s = t.noop, r = t.pick, l = t.Series, h = t.seriesType, p = t.seriesTypes; h("heatmap", "scatter", { animation: !1, borderWidth: 0, nullColor: "#f7f7f7", dataLabels: { formatter: function () { return this.point.value }, inside: !0, verticalAlign: "middle", crop: !1, overflow: !1, padding: 0 }, marker: null, pointRange: null, tooltip: { pointFormat: "{point.x}, {point.y}: {point.value}<br/>" }, states: { hover: { halo: !1, brightness: .2 } } }, n(e, { pointArrayMap: ["y", "value"], hasPointSpecificOptions: !0, getExtremesFromAll: !0, directTouch: !0, init: function () { var t; p.scatter.prototype.init.apply(this, arguments), (t = this.options).pointRange = r(t.pointRange, t.colsize || 1), this.yAxis.axisPointRange = t.rowsize || 1 }, translate: function () { var t = this.options, i = this.xAxis, e = this.yAxis, a = t.pointPadding || 0, n = function (t, i, e) { return Math.min(Math.max(i, t), e) }; this.generatePoints(), o(this.points, function (o) { var s = (t.colsize || 1) / 2, l = (t.rowsize || 1) / 2, h = n(Math.round(i.len - i.translate(o.x - s, 0, 1, 0, 1)), -i.len, 2 * i.len), p = n(Math.round(i.len - i.translate(o.x + s, 0, 1, 0, 1)), -i.len, 2 * i.len), c = n(Math.round(e.translate(o.y - l, 0, 1, 0, 1)), -e.len, 2 * e.len), d = n(Math.round(e.translate(o.y + l, 0, 1, 0, 1)), -e.len, 2 * e.len), u = r(o.pointPadding, a); o.plotX = o.clientX = (h + p) / 2, o.plotY = (c + d) / 2, o.shapeType = "rect", o.shapeArgs = { x: Math.min(h, p) + u, y: Math.min(c, d) + u, width: Math.abs(p - h) - 2 * u, height: Math.abs(d - c) - 2 * u } }), this.translateColors() }, drawPoints: function () { p.column.prototype.drawPoints.call(this), o(this.points, function (t) { t.graphic.attr(this.colorAttribs(t)) }, this) }, animate: s, getBox: s, drawLegendSymbol: a.drawRectangle, alignDataLabel: p.column.prototype.alignDataLabel, getExtremes: function () { l.prototype.getExtremes.call(this, this.valueData), this.valueMin = this.dataMin, this.valueMax = this.dataMax, l.prototype.getExtremes.call(this) } }), t.extend({ haloPath: function (t) { if (!t) return []; var i = this.shapeArgs; return ["M", i.x - t, i.y - t, "L", i.x - t, i.y + i.height + t, i.x + i.width + t, i.y + i.height + t, i.x + i.width + t, i.y - t, "Z"] } }, i)) }(t), function (t) { var i = t.Chart, e = t.each, o = t.extend, a = t.format, n = t.merge, s = t.win, r = t.wrap; function l(t, i) { var e, o, a = !1, n = t.x, s = t.y; for (e = 0, o = i.length - 1; e < i.length; o = e++)i[e][1] > s !== i[o][1] > s && n < (i[o][0] - i[e][0]) * (s - i[e][1]) / (i[o][1] - i[e][1]) + i[e][0] && (a = !a); return a } i.prototype.transformFromLatLon = function (i, e) { if (void 0 === s.proj4) return t.error(21), { x: 0, y: null }; var o = s.proj4(e.crs, [i.lon, i.lat]), a = e.cosAngle || e.rotation && Math.cos(e.rotation), n = e.sinAngle || e.rotation && Math.sin(e.rotation), r = e.rotation ? [o[0] * a + o[1] * n, -o[0] * n + o[1] * a] : o; return { x: ((r[0] - (e.xoffset || 0)) * (e.scale || 1) + (e.xpan || 0)) * (e.jsonres || 1) + (e.jsonmarginX || 0), y: (((e.yoffset || 0) - r[1]) * (e.scale || 1) + (e.ypan || 0)) * (e.jsonres || 1) - (e.jsonmarginY || 0) } }, i.prototype.transformToLatLon = function (i, e) { if (void 0 !== s.proj4) { var o = { x: ((i.x - (e.jsonmarginX || 0)) / (e.jsonres || 1) - (e.xpan || 0)) / (e.scale || 1) + (e.xoffset || 0), y: ((-i.y - (e.jsonmarginY || 0)) / (e.jsonres || 1) + (e.ypan || 0)) / (e.scale || 1) + (e.yoffset || 0) }, a = e.cosAngle || e.rotation && Math.cos(e.rotation), n = e.sinAngle || e.rotation && Math.sin(e.rotation), r = s.proj4(e.crs, "WGS84", e.rotation ? { x: o.x * a + o.y * -n, y: o.x * n + o.y * a } : o); return { lat: r.y, lon: r.x } } t.error(21) }, i.prototype.fromPointToLatLon = function (i) { var e, o = this.mapTransforms; if (o) { for (e in o) if (o.hasOwnProperty(e) && o[e].hitZone && l({ x: i.x, y: -i.y }, o[e].hitZone.coordinates[0])) return this.transformToLatLon(i, o[e]); return this.transformToLatLon(i, o.default) } t.error(22) }, i.prototype.fromLatLonToPoint = function (i) { var e, o, a = this.mapTransforms; if (!a) return t.error(22), { x: 0, y: null }; for (e in a) if (a.hasOwnProperty(e) && a[e].hitZone && l({ x: (o = this.transformFromLatLon(i, a[e])).x, y: -o.y }, a[e].hitZone.coordinates[0])) return o; return this.transformFromLatLon(i, a.default) }, t.geojson = function (t, i, n) { var s = [], r = [], l = function (t) { var i, e = t.length; for (r.push("M"), i = 0; i < e; i++)1 === i && r.push("L"), r.push(t[i][0], -t[i][1]) }; return i = i || "map", e(t.features, function (t) { var a, n = t.geometry, h = n.type, p = n.coordinates, c = t.properties; r = [], "map" === i || "mapbubble" === i ? ("Polygon" === h ? (e(p, l), r.push("Z")) : "MultiPolygon" === h && (e(p, function (t) { e(t, l) }), r.push("Z")), r.length && (a = { path: r })) : "mapline" === i ? ("LineString" === h ? l(p) : "MultiLineString" === h && e(p, l), r.length && (a = { path: r })) : "mappoint" === i && "Point" === h && (a = { x: p[0], y: -p[1] }), a && s.push(o(a, { name: c.name || c.NAME, properties: c })) }), n && t.copyrightShort && (n.chart.mapCredits = a(n.chart.options.credits.mapText, { geojson: t }), n.chart.mapCreditsFull = a(n.chart.options.credits.mapTextFull, { geojson: t })), s }, r(i.prototype, "addCredits", function (t, i) { i = n(!0, this.options.credits, i), this.mapCredits && (i.href = null), t.call(this, i), this.credits && this.mapCreditsFull && this.credits.attr({ title: this.mapCreditsFull }) }) }(t), function (t) { var i = t.Chart, e = t.defaultOptions, o = t.each, a = t.extend, n = t.merge, s = t.pick, r = t.Renderer, l = t.SVGRenderer, h = t.VMLRenderer; function p(t, i, e, o, a, n, s, r) { return ["M", t + a, i, "L", t + e - n, i, "C", t + e - n / 2, i, t + e, i + n / 2, t + e, i + n, "L", t + e, i + o - s, "C", t + e, i + o - s / 2, t + e - s / 2, i + o, t + e - s, i + o, "L", t + r, i + o, "C", t + r / 2, i + o, t, i + o - r / 2, t, i + o - r, "L", t, i + a, "C", t, i + a / 2, t + a / 2, i, t + a, i, "Z"] } a(e.lang, { zoomIn: "Zoom in", zoomOut: "Zoom out" }), e.mapNavigation = { buttonOptions: { alignTo: "plotBox", align: "left", verticalAlign: "top", x: 0, width: 18, height: 18, padding: 5, style: { fontSize: "15px", fontWeight: "bold" }, theme: { "stroke-width": 1, "text-align": "center" } }, buttons: { zoomIn: { onclick: function () { this.mapZoom(.5) }, text: "+", y: 0 }, zoomOut: { onclick: function () { this.mapZoom(2) }, text: "-", y: 28 } }, mouseWheelSensitivity: 1.1 }, t.splitPath = function (t) { var i; for (t = (t = (t = t.replace(/([A-Za-z])/g, " $1 ")).replace(/^\s*/, "").replace(/\s*$/, "")).split(/[ ,]+/), i = 0; i < t.length; i++)/[a-zA-Z]/.test(t[i]) || (t[i] = parseFloat(t[i])); return t }, t.maps = {}, l.prototype.symbols.topbutton = function (t, i, e, o, a) { return p(t - 1, i - 1, e, o, a.r, a.r, 0, 0) }, l.prototype.symbols.bottombutton = function (t, i, e, o, a) { return p(t - 1, i - 1, e, o, 0, 0, a.r, a.r) }, r === h && o(["topbutton", "bottombutton"], function (t) { h.prototype.symbols[t] = l.prototype.symbols[t] }), t.Map = t.mapChart = function (e, o, a) { var r, l = "string" == typeof e || e.nodeName, h = arguments[l ? 1 : 0], p = { endOnTick: !1, visible: !1, minPadding: 0, maxPadding: 0, startOnTick: !1 }, c = t.getOptions().credits; return r = h.series, h.series = null, (h = n({ chart: { panning: "xy", type: "map" }, credits: { mapText: s(c.mapText, ' © <a href="{geojson.copyrightUrl}">{geojson.copyrightShort}</a>'), mapTextFull: s(c.mapTextFull, "{geojson.copyright}") }, tooltip: { followTouchMove: !1 }, xAxis: p, yAxis: n(p, { reversed: !0 }) }, h, { chart: { inverted: !1, alignTicks: !1 } })).series = r, l ? new i(e, h, a) : new i(h, o) } }(t) });